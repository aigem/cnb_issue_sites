#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

console.log('🚀 开始构建CNB静态博客...\n');

// 加载环境变量
function loadEnvFile(filePath) {
  if (fs.existsSync(filePath)) {
    const envContent = fs.readFileSync(filePath, 'utf8');
    const lines = envContent.split('\n');

    lines.forEach(line => {
      line = line.trim();
      if (line && !line.startsWith('#')) {
        const [key, ...valueParts] = line.split('=');
        if (key && valueParts.length > 0) {
          const value = valueParts.join('=').trim();
          // 移除引号
          const cleanValue = value.replace(/^["']|["']$/g, '');
          // 只在环境变量不存在时才设置（优先使用系统环境变量）
          if (!process.env[key.trim()]) {
            process.env[key.trim()] = cleanValue;
          }
        }
      }
    });
    console.log(`✅ 已加载环境变量文件: ${filePath}`);
  }
}

// 设置特定CI/部署环境变量（优先使用系统环境变量）
function setupCIEnvironmentVariables() {
  // 从CNB_REPO_SLUG_LOWERCASE获取REPO值 (特定CI/部署环境)
  // 这允许在CI中通过CNB_REPO_SLUG_LOWERCASE设置REPO
  if (process.env.CNB_REPO_SLUG_LOWERCASE && !process.env.REPO) {
    process.env.REPO = process.env.CNB_REPO_SLUG_LOWERCASE;
    console.log(`🔧 REPO设置为CNB_REPO_SLUG_LOWERCASE的值: ${process.env.REPO}`);
  }

  // 从CNB_TOKEN获取AUTH_TOKEN值 (特定CI/部署环境)
  // 这允许在CI中通过CNB_TOKEN设置AUTH_TOKEN
  if (process.env.CNB_TOKEN && !process.env.AUTH_TOKEN) {
    process.env.AUTH_TOKEN = process.env.CNB_TOKEN;
    console.log('🔧 AUTH_TOKEN设置为CNB_TOKEN的值');
  }
}

// 1. 加载 .env.local 文件（如果存在，但不会覆盖已通过其他方式设置的系统环境变量）
loadEnvFile('.env.local');

// 2. 设置特定CI/部署环境变量 (可能会覆盖.env.local中的值，如果CI变量已设置)
setupCIEnvironmentVariables();

console.log('🔧 应用环境变量摘要:');
console.log(`   BASE_URL: ${process.env.BASE_URL || '未设置 (将从lib/config.ts获取默认值)'}`);
console.log(`   REPO: ${process.env.REPO || '未设置 (构建将失败)'}`);
console.log(`   AUTH_TOKEN: ${process.env.AUTH_TOKEN ? '***已设置***' : '未设置 (构建将失败)'}`);
if (process.env.CNB_REPO_SLUG_LOWERCASE) {
  console.log(`   (CI) CNB_REPO_SLUG_LOWERCASE: ${process.env.CNB_REPO_SLUG_LOWERCASE}`);
}
if (process.env.CNB_TOKEN) {
  console.log(`   (CI) CNB_TOKEN: ***已设置***`);
}
console.log('   其他NEXT_PUBLIC_*变量将由lib/config.ts处理 (默认值, blog.config.json, 或环境变量)\n');

// 验证构建过程必需的环境变量
// BASE_URL也由lib/config.ts处理其默认值，但如果API在构建时就需要，则可能需要检查
// 对于此项目，API调用主要在运行时或getStaticProps/getServerSideProps，
// 但next.config.js中的env使其在构建时可用。
// lib/config.ts会提供默认值，所以这里不强制检查BASE_URL。
const criticalEnvVars = ['REPO', 'AUTH_TOKEN'];
const missingVars = criticalEnvVars.filter(varName => !process.env[varName]);

if (missingVars.length > 0) {
  console.error('❌ 缺少构建过程必需的环境变量:');
  missingVars.forEach(varName => {
    console.error(`   - ${varName}`);
  });
  console.error('\n请确保以下环境变量已设置 (例如, 在.env.local文件或系统环境变量中):');
  console.error('   - REPO (或者通过CNB_REPO_SLUG_LOWERCASE在CI中设置)');
  console.error('   - AUTH_TOKEN (或者通过CNB_TOKEN在CI中设置)');
  console.error('\nCNB博客构建失败。');
  process.exit(1);
}

// BASE_URL的检查被移除，因为lib/config.ts有默认值。
// 如果特定构建步骤绝对需要它，并且不能依赖lib/config.ts的默认值，
// 则应将其添加回criticalEnvVars。

console.log('✅ 构建过程必需的环境变量已设置。\n');

try {
  // 清理之前的构建
  console.log('🧹 清理之前的构建文件...');

  // 跨平台删除目录
  function removeDir(dirPath) {
    if (fs.existsSync(dirPath)) {
      try {
        fs.rmSync(dirPath, { recursive: true, force: true });
        console.log(`   ✅ 已删除: ${dirPath}`);
      } catch (error) {
        console.log(`   ⚠️  删除失败: ${dirPath} - ${error.message}`);
      }
    }
  }

  removeDir('out');
  removeDir('.next');

  // 安装依赖
  console.log('📦 检查依赖...');
  if (!fs.existsSync('node_modules')) {
    console.log('📦 安装依赖...');
    execSync('pnpm install --frozen-lockfile', { stdio: 'inherit' });
  }

  // 构建项目
  console.log('🔨 构建Next.js项目...');
  execSync('pnpm build', { stdio: 'inherit' });

  // 注意：Next.js 15 的 output: 'export' 会自动导出，不需要单独的 export 命令
  console.log('✅ 静态文件已自动导出到 out 目录');

  // 生成额外的静态文件 (sitemap.xml and rss.xml are now generated by Next.js Route Handlers)
  console.log('📄 处理额外的静态文件...');

  // 复制robots.txt（如果不存在）
  // NEXT_PUBLIC_SITE_URL is used here. Ensure it's set for correct Sitemap URL in robots.txt.
  // It will default to 'https://blog.example.com' if not set, which might be incorrect for production.
  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://blog.example.com';
  if (siteUrl === 'https://blog.example.com' && process.env.NODE_ENV === 'production') {
    console.warn('⚠️  NEXT_PUBLIC_SITE_URL is not set. The Sitemap URL in robots.txt might be incorrect.');
    console.warn('   Please set NEXT_PUBLIC_SITE_URL in your environment or blog.config.json (site.url).');
  }

  if (!fs.existsSync('out/robots.txt')) {
    const robotsTxt = `User-agent: *
Allow: /

Disallow: /api/
Disallow: /_next/
Disallow: /admin/

Sitemap: ${siteUrl}/sitemap.xml

Crawl-delay: 1`;
    fs.writeFileSync('out/robots.txt', robotsTxt);
  }

  // 检查构建结果
  console.log('✅ 检查构建结果...');
  const outDir = 'out';
  const stats = fs.statSync(outDir);

  if (stats.isDirectory()) {
    const files = fs.readdirSync(outDir);
    console.log(`📊 构建完成！生成了 ${files.length} 个文件/目录`);

    // 显示主要文件
    const mainFiles = files.filter(file =>
      file.endsWith('.html') ||
      file.endsWith('.xml') ||
      file.endsWith('.txt') ||
      file === '_next'
    );

    console.log('📁 主要文件:');
    mainFiles.forEach(file => {
      console.log(`   - ${file}`);
    });
  }

  console.log('\n🎉 构建成功完成！');
  console.log(`📂 静态文件位于: ${path.resolve(outDir)}`);
  console.log('🚀 现在可以部署到任何静态托管服务了！');

} catch (error) {
  console.error('\n❌ 构建失败:', error.message);
  process.exit(1);
}
